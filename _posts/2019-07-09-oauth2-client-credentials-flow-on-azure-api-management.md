---
layout: post
title: OAuth 2.0 Authorisation with the Client Credentials Flow on Azure API Management
date: 2019-07-09 10:00
author: Paco de la Cruz
comments: true
category: Azure API Management
tags: [Azure API Management, OAuth 2.0, Security]
---

<base target="_blank"/>
<h2><img src="/assets/img/2019/07/00-cover.jpg" alt="00-cover" width="1467" style="width: 1467px;"></h2>
<p style="text-align: justify;">A well-adopted way of protecting APIs is by using the <a href="https://tools.ietf.org/html/rfc6749" rel="noopener" target="_blank">OAuth 2.0</a> authorisation standard. OAuth 2.0 offers different <a href="https://tools.ietf.org/html/rfc6749#section-1.3" rel="noopener" target="_blank">grant types</a>, also known as flows, to cover multiple authorisation scenarios. As an end-user, you most probably have used, in one way or another, the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-auth-code-flow" rel="noopener" target="_blank">authorisation code flow</a>, in which you, as a resource owner, grant access to a third-party app to your resources or information. The <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-oauth2-client-creds-grant-flow" rel="noopener" target="_blank">client credentials flow</a> is a different grant type which allows implementing OAuth 2.0 authorisation between applications.</p>
<!--more-->
<p style="text-align: justify;">When exposing APIs on <a href="https://azure.microsoft.com/en-au/services/api-management/" rel="noopener" target="_blank">Azure API Management</a> (APIM), it is common to have service-to-service communication scenarios where APIs are consumed by other applications without having a user interacting with the client application. At the time of writing, the <a href="https://docs.microsoft.com/en-us/azure/api-management/api-management-howto-protect-backend-with-aad" rel="noopener" target="_blank">official documentation</a> explains how to configure the OAuth 2.0 authorisation code flow to protect APIs on API Management. However, it does not describe in detail how to enable the client credentials flow. In this post, I will cover how to secure API Management using OAuth 2.0 authorisation with the client credentials flow.</p>
<h2>Tools of the trade and pre-requisites</h2>
<p style="text-align: justify;">To secure API Management using the OAuth 2.0 client credentials flow, we will need:</p>
<ul style="text-align: justify;">
<li>An Azure API Management instance</li>
<li>Admin access to the Azure AD tenant</li>
</ul>
<p style="text-align: justify;">Additionally, we will need the tools below:</p>
<ul>
<li style="text-align: justify;"><a href="https://code.visualstudio.com/" rel="noopener" target="_blank">VS Code</a> with the extensions listed as follows:</li>
<li style="text-align: justify;"><a href="https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-apimanagement" rel="noopener" target="_blank">Azure API Management extension for VS Code</a> for creating APIs, operations and to edit our policy.</li>
<li style="text-align: justify;"><a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" rel="noopener" target="_blank">Rest Client extension for VS Code</a> for sending HTTP requests and to test our configuration.</li>
<li style="text-align: justify;"><a href="https://marketplace.visualstudio.com/items?itemName=igor-uzhviev.jwt-decoder" rel="noopener" target="_blank">JWT Decoder extension for VS Code</a> for inspecting the Azure AD OAuth 2.0 JSON Web Tokens (JWTs). I don’t recommend using public sites to inspect your JWTs, unless you are sure that the decoding only happens on the client side, i.e. never sent to a non-trusted server. One good option is to use <a href="https://jwt.ms/" rel="noopener" target="_blank">jwt.ms</a><span>,</span> which provides very useful notes on each of the claims in Azure AD JWTs.</li>
</ul>
<p>Once we have these prerequisites and tools, let’s start with our configuration.</p>
<h2>Creating the API and Operation on APIM</h2>
<p style="text-align: justify;">The first thing we need to do on APIM is creating the API and operation where we are going to implement the OAuth 2.0 authorisation with client credentials flow.</p>
<p style="text-align: justify;">Inside the operation, I’ll use a very simple policy, so I can easily test the OAuth 2.0 authorisation part.</p>
<p style="text-align: justify;">Below is a snippet of the policy I’ll start with. It simply returns a static response, but that should be good enough for this exercise.</p>
<pre>&lt;inbound&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;return-response&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;set-status code="200" /&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;set-header name="content-type" exists-action="override"&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;application/json&lt;/value&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/set-header&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;set-body&gt;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"status": "200",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"message": "OK"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&lt;/set-body&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;/return-response&gt;<br>&nbsp;&lt;/inbound&gt;</pre>
<p style="text-align: justify;">Once we’ve created the API, we can call it from VS Code with the REST Client extension.</p>
<p style="text-align: justify;">You can find all the documentation of the extension <a href="https://marketplace.visualstudio.com/items?itemName=humao.rest-client" rel="noopener" target="_blank">here</a>.</p>
<ol>
<li style="text-align: justify;">Create a new file using the <code>.http</code> file extension, e.g. <code>oauthRequests.http</code>.</li>
<li style="text-align: justify;">In your file, add the instructions to send a request to your endpoint, e.g.</li>
</ol>
<pre>GET https://myapim.azure-api.net/oauth/test<br>Ocp-Apim-Subscription-Key: ••••••••••••••••••••••••••••••••<br>Ocp-Apim-Trace: true</pre>
<ol start="3">
<li style="text-align: justify;">You should be able to get the static response we added in the policy. Nothing too exciting yet but bear with me :)</li>
</ol>
<pre>{<br>  "status": "200",<br>  "message": "OK"<br>}</pre>
<h2>Creating App Registrations on the Microsoft Identity platform (Azure AD)</h2>
<p>Now, we need to create the app registrations that will enable us to implement the OAuth 2.0 authorisation with the client credentials flow. You can follow the instructions on how to create app registrations <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/quickstart-register-app" rel="noopener" target="_blank">here</a>.</p>
<p>We need to create two apps registrations, one representing the API Proxy and one representing the API Client. In my case, I’ve named them:</p>
<ul>
<li><code>apiproxy-oauth-app</code></li>
<li><code>apiclient-oauth-app</code></li>
</ul>
<p>In both cases, I kept the default settings as we don’t need a redirect URI and the apps only need to be accessed within my organisational directory.</p>
<p>Additionally, for the API Proxy (<code>apiproxy-oauth-app</code>) app registration, <strong>we need to set the App ID URI</strong>. This is required for the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-overview" rel="noopener" target="_blank">Microsoft Identity Platform v2.0</a>. Through this post, I’ll be exploring both v2.0 and v1.0. While the v2.0 <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/azure-ad-endpoint-comparison" rel="noopener" target="_blank">provides more flexibility</a>, at the time of writing, there are <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/azure-ad-endpoint-comparison#limitations" rel="noopener" target="_blank">some limitations</a> you need to be aware of. &nbsp;</p>
<ol>
<li>On the API Proxy app registration, navigate to <strong>Expose an API</strong></li>
<li>Then, click on <strong>Application ID URI</strong> <strong>- Set</strong>, and leave the default value, which should be <code><code>api://&lt;clientId&gt;</code></code></li>
<li>Click on <strong>Save</strong></li>
</ol>
<p><img src="/assets/img/2019/07/21-Set-Application-ID-URI.png" alt="21-Set-Application-ID-URI" width="1184" style="width: 1184px;"></p>
<p style="text-align: justify;">For both applications, take note of the application (Client) ID, as we will need them later. Also, take note of your Azure AD Tenant ID.</p>
<p style="text-align: justify;">Now, we need to <strong>create a secret</strong> for the app registration representing the API client.</p>
<ol style="text-align: justify;">
<li>Navigate to the <strong>API client</strong> app registration, in my case <code>apiclient-oauth-app</code>.</li>
<li>Navigate to <strong>Certificate &amp; Secrets, </strong>and add a secret specifying the expiration date based on your requirements.</li>
<li>Take a note of the generated secret and keep it safe. Once you close this window, you won’t be able to see it again.</li>
</ol>
<p style="text-align: justify;">I suggest recording all these details in the <code>oauthRequests.http</code> file we created previously. The REST Client extension allows you to define variables and use them in your HTTP requests. Please make sure this is just a working file and you don’t check in any secrets into your source control or store them in plain text.</p>
<p style="text-align: justify;">Your file should now look like the one below. &nbsp;</p>
<pre>@tenandId=de270000-0000-0000-84d2-000000d640bc<br>@apiProxyClientId = 80c40000-0000-4ef6-0000-0000d66eb2b8<br>@apiClientClientId = 3000000c-8593-0000-a76b-fbeff8000026<br>@apiClientSecret = *****************************<br><br><br>### Call the Protected endpoint<br>GET https://myapim.azure-api.net/oauth/test</pre>
<h2>Getting the JSON Web Token (JWT) for the API client app</h2>
<p style="text-align: justify;">To test out that our configuration is correct so far, we can call the Azure AD token endpoint with the corresponding client credentials to see whether we get a valid token.</p>
<p style="text-align: justify;">In the sample requests below I show how the token endpoints and request payloads should look like. I’m testing the token endpoints of both versions, just to make sure that clients working with both versions will be supported in my APIM policy.</p>
<p>&nbsp;</p>
<pre>### Get the apiClient token using the v2 endpoint. It requires to Set the Application Id URI<br>POST https://login.microsoftonline.com/{{tenandId}}/oauth2/v2.0/token<br>Content-Type: application/x-www-form-urlencoded<br><br>client_id={{apiClientClientId}}<br>&amp;client_secret={{apiClientSecret}}<br>&amp;scope=api://{{apiProxyClientId}}/.default<br>&amp;grant_type=client_credentials<br><br>### Get the apiClient token using the v1 endpoint.<br>POST https://login.microsoftonline.com/{{tenandId}}/oauth2/token<br>Content-Type: application/x-www-form-urlencoded<br><br>client_id={{apiClientClientId}}<br>&amp;client_secret={{apiClientSecret}}<br>&amp;grant_type=client_credentials<br>&amp;resource={{apiProxyClientId}}</pre>
<p>Now your <code>.http</code> file should look like the one below:</p>
<pre>@tenandId=de270000-0000-0000-84d2-000000d640bc<br>@apiProxyClientId = 80c40000-0000-4ef6-0000-0000d66eb2b8<br>@apiClientClientId = 3000000c-8593-0000-a76b-fbeff8000026<br>@apiClientSecret = *****************************<br><br>### Get the apiClient token using the v2 endpoint. It requires to Set the Application Id URI<br>POST https://login.microsoftonline.com/{{tenandId}}/oauth2/v2.0/token<br>Content-Type: application/x-www-form-urlencoded<br><br>client_id={{apiClientClientId}}<br>&amp;client_secret={{apiClientSecret}}<br>&amp;scope=api://{{apiProxyClientId}}/.default<br>&amp;grant_type=client_credentials<br><br>### Get the apiClient token using the v1 endpoint.<br>POST https://login.microsoftonline.com/{{tenandId}}/oauth2/token<br>Content-Type: application/x-www-form-urlencoded<br><br>client_id={{apiClientClientId}}<br>&amp;client_secret={{apiClientSecret}}<br>&amp;grant_type=client_credentials<br>&amp;resource={{apiProxyClientId}}<br><br>### Call the Protected endpoint<br>GET https://myapim.azure-api.net/oauth/test</pre>
<p>We are ready to send a request to the token endpoints. If you send a request to the v2.0 endpoint, you should get a JWT similar to the one below:</p>
<pre>{<br>  "token_type": "Bearer",<br>  "expires_in": 3600,<br>  "ext_expires_in": 3600,<br>  "access_token": "eyJ0eXAiOiJKV........."<br>}</pre>
<p style="text-align: justify;">And the v1.0 endpoint should return to you a token like the one as follows:</p>
<pre>{<br>  "token_type": "Bearer",<br>  "expires_in": "3600",<br>  "ext_expires_in": "3600",<br>  "expires_on": "1561347561",<br>  "not_before": "1561343661",<br>  "resource": "80c40000-0000-4ef6-0000-0000d66eb2b8",<br>  "access_token": "eyJ0eXAiOiJKV.........."<br>}</pre>
<p style="text-align: justify;">Now you can copy the content of the <code>access_token</code>, and use the JWT Decoder extension on VS Code to inspect the token.</p>
<p style="text-align: justify;">Your decoded JWT v2.0 should look like the one below:</p>
<pre>{<br> &nbsp;&nbsp; "aud": "api://80c40000-0000-4ef6-0000-0000d66eb2b8",<br> &nbsp;&nbsp; "iss": "https://sts.windows.net/de270000-0000-0000-84d2-000000d640bc/",<br> &nbsp;&nbsp; "iat": "[Local:GMT+10]: 24 Jun 2019, 12:37:48 // [UTC]: 24 Jun 2019, 2:37:48",<br> &nbsp;&nbsp; "nbf": "[Local:GMT+10]: 24 Jun 2019, 12:37:48 // [UTC]: 24 Jun 2019, 2:37:48",<br> &nbsp;&nbsp; "exp": "[Local:GMT+10]: 24 Jun 2019, 13:42:48 // [UTC]: 24 Jun 2019, 3:42:48",<br> &nbsp;&nbsp; "aio": "42Zg...gA=",<br> &nbsp;&nbsp; "appid": "3000000c-8593-0000-a76b-fbeff8000026",<br> &nbsp;&nbsp; "appidacr": "1",<br> &nbsp;&nbsp; "idp": "https://sts.windows.net/de270000-0000-0000-84d2-000000d640bc/",<br> &nbsp;&nbsp; "oid": "fa3d0000-0000-0000-0000-000016c37e02",<br> &nbsp;&nbsp; "sub": "fa3d0000-0000-0000-0000-000016c37e02",<br> &nbsp;&nbsp; "tid": "de270000-0000-0000-84d2-000000d640bc",<br> &nbsp;&nbsp; "uti": "Ygby...AA",<br> &nbsp;&nbsp; "ver": "1.0"<br>}</pre>
<p>And the decoded JWT v1.0 should be similar to the one as follows:</p>
<pre>{<br> &nbsp;&nbsp; "aud": "80c40000-0000-4ef6-0000-0000d66eb2b8",<br> &nbsp;&nbsp; "iss": "https://sts.windows.net/de270000-0000-0000-84d2-000000d640bc/",<br> &nbsp;&nbsp; "iat": "[Local:GMT+10]: 24 Jun 2019, 12:34:21 // [UTC]: 24 Jun 2019, 2:34:21",<br> &nbsp;&nbsp; "nbf": "[Local:GMT+10]: 24 Jun 2019, 12:34:21 // [UTC]: 24 Jun 2019, 2:34:21",<br> &nbsp;&nbsp; "exp": "[Local:GMT+10]: 24 Jun 2019, 13:39:21 // [UTC]: 24 Jun 2019, 3:39:21",<br> &nbsp;&nbsp; "aio": "42bg...AA==",<br> &nbsp;&nbsp; "appid": "3000000c-8593-0000-a76b-fbeff8000026",<br> &nbsp;&nbsp; "appidacr": "1",<br> &nbsp;&nbsp; "idp": "https://sts.windows.net/de270000-0000-0000-84d2-000000d640bc/",<br> &nbsp;&nbsp; "oid": "fa3d0000-0000-0000-0000-000016c37e02",<br> &nbsp;&nbsp; "sub": "fa3d0000-0000-0000-0000-000016c37e02",<br> &nbsp;&nbsp; "tid": "de270000-0000-0000-84d2-000000d640bc",<br> &nbsp;&nbsp; "uti": "Hrsi...AA",<br> &nbsp;&nbsp; "ver": "1.0"<br>}</pre>
<p style="text-align: justify;">As we can see, we have been able to create the app registrations and successfully get a JWT for the client app using the client credentials. So far, so good!</p>
<h2>Considerations on using the client credentials flow on APIM</h2>
<p style="text-align: justify;">Now that we have created the app registrations and tested that we can get a JWT for the client app successfully, we need to configure our API on API Management to validate the JWT and its claims for checking whether the client is authorised to call the API.</p>
<p style="text-align: justify;">As mentioned above, at the time of writing, the <a href="https://docs.microsoft.com/en-us/azure/api-management/api-management-howto-protect-backend-with-aad" rel="noopener" target="_blank">official documentation</a> only explains how to configure the OAuth 2.0 authorisation code flow on APIM. So here are some of the differences when configuring the client credentials flow.</p>
<ul>
<li style="text-align: justify;"><strong>Granting </strong><a href="https://docs.microsoft.com/en-gb/azure/active-directory/develop/developer-glossary#permissions" rel="noopener" target="_blank"><strong>permissions</strong><span style="color: #666666;"> -</span></a><span style="color: #666666;">&nbsp;</span>While the <a href="https://docs.microsoft.com/en-us/azure/api-management/api-management-howto-protect-backend-with-aad#grant-permissions-in-azure-ad" rel="noopener" target="_blank">documentation <span style="color: #666666;">describes</span></a> how to grant <span style="color: #666666;"><em><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent#permission-types" rel="noopener" target="_blank" style="color: #666666;">d</a><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent#permission-types" rel="noopener" target="_blank" style="color: #666666;">elegated permissions</a></em></span>, these are only applicable when there is a signed-in user, which is not the case in the client credentials flow. So, we need to use <em><span style="color: #666666;"><a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent#permission-types" rel="noopener" target="_blank" style="color: #666666;">application permissions</a></span></em><strong>, </strong>which are applicable in service-to-service scenarios.</li>
<li style="text-align: justify;"><strong>Enabling user authorisation in the developer console </strong>-&nbsp;In the <a href="https://docs.microsoft.com/en-us/azure/api-management/api-management-howto-protect-backend-with-aad#enable-oauth-20-user-authorization-in-the-developer-console" rel="noopener" target="_blank">documentation</a>, it is suggested to enable user authorisation to be used in the developer console. In this case, we are only using client credentials, thus it is not applicable.</li>
</ul>
<h2>Validating the Audience Claim in the APIM policy</h2>
<p style="text-align: justify;">Now, we can start configuring the APIM policy to implement the OAuth 2.0 authorisation by validating the claims in the JWT sent by the client application. In the <a href="https://docs.microsoft.com/en-us/azure/api-management/api-management-howto-protect-backend-with-aad#configure-a-jwt-validation-policy-to-pre-authorize-requests" rel="noopener" target="_blank">official documentation</a> (at the time of writing) and different samples I’ve seen, they suggest to validate the audience claim in the APIM policy.</p>
<p style="text-align: justify;">According to the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/id-tokens" rel="noopener" target="_blank">official reference</a>, the audience claim (<code>aud</code>):</p>
<blockquote>
<p>Identifies the intended recipient of the token. In id_tokens, the audience is your app's Application ID, assigned to your app in the Azure portal. Your app should validate this value, and reject the token if the value does not match.</p>
</blockquote>
<p style="text-align: justify;">This means that the audience claim should only be used to validate that a token was issued targeting your application. This <strong>does not</strong> imply that there are any permissions granted to the caller. Without testing it, we can even see how the JWTs above returned the <code>aud</code> field with the intended receiver without having given any access to the client application on Azure AD.&nbsp; &nbsp;</p>
<p style="text-align: justify;">Let’s test this out! So far, we have only created the two app registrations without granting any access to the client app. Let’s add the <code>validate-jwt</code> policy to the API operation. In the policy shown below, I’ve done this. I’ve adding two possible values to allow tokens generated by both - the v1.0 and v2.0 token endpoints. When you implement it, you can stick to the version you know you are going to use.</p>
<pre>&nbsp;&nbsp;&nbsp; &lt;inbound&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized. Access token is missing or invalid."&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;openid-config url="https://login.microsoftonline.com/de270000-0000-0000-84d2-000000d640bc/.well-known/openid-configuration" /&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;required-claims&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;claim name="aud" match="any"&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value&gt;api://80c40000-0000-4ef6-0000-0000d66eb2b8&lt;/value&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value&gt;80c40000-0000-4ef6-0000-0000d66eb2b8&lt;/value&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/claim&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/required-claims&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/validate-jwt&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;return-response&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;set-status code="200" /&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;set-header name="content-type" exists-action="override"&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value&gt;application/json&lt;/value&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/set-header&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;set-body&gt;{<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "status": "200",<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "message": "OK"<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&lt;/set-body&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/return-response&gt;<br> &nbsp;&nbsp; &lt;/inbound&gt;</pre>
<p>&nbsp;</p>
<p style="text-align: justify;">In order to test this when calling the endpoint implementing the OAuth authorisation, we need to add the <code>Authorization</code> header with the bearer token that we got from the token endpoint. Now your <code>.http</code> file should look like the one below:</p>
<pre>@tenandId=de270000-0000-0000-84d2-000000d640bc<br>@apiProxyClientId = 80c40000-0000-4ef6-0000-0000d66eb2b8<br>@apiClientClientId = 3000000c-8593-0000-a76b-fbeff8000026<br>@apiClientSecret = *****************************<br><br>### Get the apiClient token using the v2 endpoint. It requires to Set the Application Id URI<br>POST https://login.microsoftonline.com/{{tenandId}}/oauth2/v2.0/token<br>Content-Type: application/x-www-form-urlencoded<br><br>client_id={{apiClientClientId}}<br>&amp;client_secret={{apiClientSecret}}<br>&amp;scope=api://{{apiProxyClientId}}/.default<br>&amp;grant_type=client_credentials<br><br>### Get the apiClient token using the v1 endpoint.<br>POST https://login.microsoftonline.com/{{tenandId}}/oauth2/token<br>Content-Type: application/x-www-form-urlencoded<br><br>client_id={{apiClientClientId}}<br>&amp;client_secret={{apiClientSecret}}<br>&amp;grant_type=client_credentials<br>&amp;resource={{apiProxyClientId}}<br><br>### Call the Protected endpoint<br>GET https://myapim.azure-api.net/oauth/test<br>Authorization: Bearer eyJ0eXAQ....</pre>
<p style="text-align: justify;">Now that we have added the audience claim validation to the APIM policy, let’s call the endpoint including the <code>Authorization</code>header with the bearer token. We should be getting a 200 response. In this very case, it is not what we want, as we have not given any permissions to the client app to call the proxy app. As we have seen, validating the audience claim is certainly not enough.</p>
<h2>Validating the client application ClientId in the APIM policy</h2>
<p style="text-align: justify;">As we have tested, validating the audience is not sufficient. One approach we can follow is to validate the <code>appid</code> claim to check whether the caller is authorised to call the endpoint. Let us include that required claim into our policy, in addition to the audience validation. If we want to allow multiple applications to call the endpoint, we just need to add all authorised <code>appids</code>.</p>
<pre>&nbsp;&nbsp;&nbsp; &lt;inbound&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized. Access token is missing or invalid."&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;openid-config url="https://login.microsoftonline.com/de270000-0000-0000-84d2-000000d640bc/.well-known/openid-configuration" /&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;required-claims&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;claim name="aud" match="any"&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value&gt;api://80c40000-0000-4ef6-0000-0000d66eb2b8&lt;/value&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&lt;value&gt;80c40000-0000-4ef6-0000-0000d66eb2b8&lt;/value&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/claim&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;claim name="appid" match="any"&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value&gt;3000000c-8593-0000-a76b-fbeff8000026&lt;/value&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value&gt;f81a0000-0000-0000-0000-0000c1e95d85&lt;/value&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/claim&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/required-claims&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/validate-jwt&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;return-response&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;set-status code="200" /&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;set-header name="content-type" exists-action="override"&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value&gt;application/json&lt;/value&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/set-header&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;set-body&gt;{<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "status": "200",<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "message": "OK"<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&lt;/set-body&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/return-response&gt;<br> &nbsp;&nbsp; &lt;/inbound&gt;</pre>
<p style="text-align: justify;">After testing this, we are able to get a 200 response. We will only be authorised to call the endpoint if both claims, <code>aud</code> and <code>appid</code> exist and values match any of the values in the authorised list.</p>
<p style="text-align: justify;">This approach is quite straight forward. The advantage of this is that the OAuth authorisation can be configured directly within the APIM policy and from our release pipeline without requiring an Azure AD admin. However, this is not necessarily desirable in all scenarios, where more strict controls must be in place.</p>
<h2>Granting Application Permissions to the client app</h2>
<p style="text-align: justify;">Above we have discussed how to implement authorisation at the policy level without requiring granting permissions in Azure Active Directory. In some scenarios, this could meet the requirements. But let’s explore now how to implement role-based access control (RBAC) granted by an Azure AD administrator to restrict access to an API on Azure API Management.</p>
<p style="text-align: justify;">The first thing we need to do is to add <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-permissions-and-consent#permission-types" rel="noopener" target="_blank">application permissions</a> to the API proxy app registration. This is required to implement the OAuth 2.0 client credentials flow using RBAC. For this, we need go to the API Proxy app registration in Azure Active Directory, in my case <code>apiproxy-oauth-app</code>, and edit its <em>Manifest</em>. We will need to add an entry into the <code>appRoles</code> array specifying that the permission is for an application. You can find more details in the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/howto-add-app-roles-in-azure-ad-apps" rel="noopener" target="_blank">documentation</a>. The <code>appRoles</code> array should now look similar to the one below. Make sure you create a new <code>GUID</code> for your app role <code>id</code>.&nbsp;</p>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "appRoles": [<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "allowedMemberTypes": [<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Application"<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ],<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "description": "Allow client apps to send requests to the API.",<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "displayName": "API Request",<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "id": "cfef0000-0000-0000-be10-90e97fa573a6",<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "isEnabled": true,<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "lang": null,<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "origin": "Application",<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "value": "API.Request"<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br> &nbsp;&nbsp;&nbsp;&nbsp; ]</pre>
<p>&nbsp;</p>
<p>After editing the application manifest and saving the changes. Now we should be able to grant permissions to the client app by following the steps below.</p>
<ol>
<li>Navigate to <strong>Azure Active Directory</strong></li>
<li>Navigate to <strong>App Registrations</strong></li>
<li>Navigate to your <strong>client application</strong>, e.g. <code>apiclient-oauth-app</code></li>
<li>Navigate to <strong>API Permissions</strong></li>
<li>Click on <strong>Add a Permission</strong><br><strong><img src="/assets/img/2019/07/41-Add-API-Permissions.png" alt="41-Add-API-Permissions" width="1148" style="width: 1148px;"></strong></li>
<li>Search for your <strong>API application</strong>, e.g. <code>apiproxy-oauth-app</code><img src="/assets/img/2019/07/42-Request-API-Permissions.png" alt="42-Request-API-Permissions" width="1102" style="width: 1102px;"></li>
<li>Click on <strong>Application Permissions</strong><br><strong><img src="/assets/img/2019/07/43-Select-App-Permissions.png" alt="43-Select-App-Permissions" width="1461" style="width: 1461px;"></strong></li>
<li><strong>Select the role</strong> you added previously, e.g. <code>Request</code></li>
<li>Click on <strong>Add permissions</strong></li>
<li>Make sure the permission you just added is listed</li>
<li>Click on <strong>Grant admin consent. </strong>This step requires Azure AD admin privileges.<img src="/assets/img/2019/07/44-Admin-Consent.png" alt="44-Admin-Consent" width="1167" style="width: 1167px;"></li>
<li>Click on <strong>Yes</strong></li>
<li>Make sure the permission has now granted admin consent.</li>
</ol>
<h2>Validating the Application Permissions (Roles) claim in the APIM policy</h2>
<p style="text-align: justify;">Once we have granted role-based access to the client application to call the API, we can validate the roles claim in the APIM policy. By validating the audience, we are making sure that the token targets our API, and by validating the roles, we are making sure the caller has the correct role-based access to the API.</p>
<p style="text-align: justify;">The APIM policy for validating the roles claim is shown below. While creating your policy, consider that the validation is case sensitive.</p>
<pre>&nbsp;&nbsp;&nbsp; &lt;inbound&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&lt;validate-jwt header-name="Authorization" failed-validation-httpcode="401" failed-validation-error-message="Unauthorized. Access token is missing or invalid."&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;openid-config url="https://login.microsoftonline.com/de270000-0000-0000-84d2-000000d640bc/.well-known/openid-configuration" /&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;required-claims&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;claim name="aud" match="any"&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value&gt;api://80c40000-0000-4ef6-0000-0000d66eb2b8&lt;/value&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value&gt;80c40000-0000-4ef6-0000-0000d66eb2b8&lt;/value&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/claim&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;claim name="roles" match="any"&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value&gt;API.Request&lt;/value&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/claim&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/required-claims&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/validate-jwt&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;return-response&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;set-status code="200" /&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;set-header name="content-type" exists-action="override"&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;value&gt;application/json&lt;/value&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/set-header&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;set-body&gt;{<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "status": "200",<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "message": "OK"<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&lt;/set-body&gt;<br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &lt;/return-response&gt;<br> &nbsp;&nbsp; &lt;/inbound&gt;</pre>
<p style="text-align: justify;">For scenarios where role-based access control to APIs is managed by an Azure AD administrator, this is the approach you want to follow.</p>
<h2>Wrapping up</h2>
<p style="text-align: justify;">In this post, we have discussed how to implement authorisation on Azure API Management using the OAuth 2.0 client credentials flow, which is designed for service-to-service scenarios. We have discussed why validating the audience only is not a proper authorisation implementation, and explored two options to implement the authorisation. One option that is fully controlled in the APIM policy only, and another that requires consent form an Azure AD administrator. You can implement the one that makes more sense to you according to your requirements.</p>
<p style="text-align: justify;">I hope you have found this post useful. Please feel free to post your comments or questions below!</p>
<p style="text-align: justify;">Happy clouding!</p>

<p style="text-align:center;"><span style="font-style:italic;">Cross-posted on </span><a href="https://engineering.deloitte.com.au/articles/author/paco-de-la-cruz"><span style="font-style:italic;">Deloitte Engineering</span></a><br/>
<span style="font-style:italic;">Follow me on </span><a href="https://twitter.com/pacodelacruz"><span style="font-style:italic;">@pacodelacruz</span></a></p>